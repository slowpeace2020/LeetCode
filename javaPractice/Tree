===================2020.11.19======================

*563. Binary Tree Tilt
后序遍历非递归方案，双栈（）前序遍历反过来，单栈比较当前弹出值和之前弹出值，以判断此节点的右子节点是否已访问
其实是很简单的后序遍历，递归可解，抓住本质定义，左右子节点和之差,后序遍历求每个节点的子节点之和，顺便把左右子节点的差都加起来就是根节点的值
refer: https://zhuanlan.zhihu.com/p/80578741

437. Path Sum III
应该是不难的，想清楚一个问题，一个问题返回的值并不一样必须是最终结果，也可以夹带我们想要处理的过程值，
这道题要求的是从一个节点出发，到另外一个节点，必须从父到子节点，父不必是根结点，子不必是叶子节点，和等于特定值的路径数量
那递归好了，一个是从当前节点出发的有效路径，再加上它的子节点为根节点的所有路径，效率不是很高，后续优化

654. Maximum Binary Tree
简单题，递归秒杀，读懂题意很简单，每次找剩下的最大的点作为根节点，这个点左边剩下的为左子节点备选元素，右边为右子节点备选元素，递归即可

===================2020.11.20======================
606. Construct String from Binary Tree
简单题，递归秒杀，注意左右子节点为空的不同处理

617. Merge Two Binary Trees
简单题，递归秒杀，两棵树值合并

623. Add One Row to Tree
简单题，层级遍历，注意深度和根节点的关系，从哪里开始

637. Average of Levels in Binary Tree
简单题，层级遍历，每一层求均值

*653. Two Sum IV - Input is a BST
怎么遍历都行，找值在不在，也可以前序遍历，在有序数组中找

508. Most Frequent Subtree Sum
简单题，遍历求以每个节点为根的和，顺便统计这些和的频率，保留最高的

先排除所有hard和20%一下通过率的题
